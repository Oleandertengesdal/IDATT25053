"""
Exercise 4: CTR Mode with AES SubBytes

We can construct a key-stream by using a block cipher in
CTR-mode, by simply encrypting a sequence of values with
a block cipher. It will use a nonce (initial value) combined
with a counter. Here we will use addition modulo 2^8 = 256
as the operation combining the nonce and the counter. The
counter starts at 0, and add 1 to it for each round.

For the block cipher in parts a)-c) below, we use the SUBBYTES
of the AES cipher, which substitutes a byte (8 bits) for
another byte using a table lookup (actually a calculation in
a certain Galois field, but it's not in the curriculum).

Write programs to do the calculations.

a) Using the nonce = 01100101, write down the first 4 bytes
   produced with counter values 0,1,2,3.
b) What is the period of the key-stream?
c) Can the computation of the keystream be easily parallelized?
d) You intercept a message which is encrypted by XOR-ing a
   key-stream generated by CTR, as described above, but
   with an unknown block cipher (not the one above). How
   could information about known plaintexts-ciphertext pairs
   be used to infer information about the key used?
"""

# AES S-box (SubBytes lookup table)
s_box = (
    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16,
)


def bits_to_int(bits):
    """Convert list of bits to integer."""
    return int(''.join(map(str, bits)), 2)


def int_to_bits(n, width=8):
    """Convert integer to list of bits with specified width."""
    return [int(b) for b in format(n, f'0{width}b')]


def sub_bytes(byte_value):
    """
    Apply AES SubBytes transformation.
    
    Args:
        byte_value: Integer value (0-255)
        
    Returns:
        Substituted byte value using AES S-box
    """
    return s_box[byte_value]


def ctr_keystream_byte(nonce, counter):
    """
    Generate one byte of CTR mode keystream.
    
    Process:
    1. Combine nonce and counter: (nonce + counter) mod 256
    2. Apply block cipher (SubBytes in this case)
    
    Args:
        nonce: Nonce value (0-255)
        counter: Counter value
        
    Returns:
        One keystream byte
    """
    # Combine nonce and counter using addition mod 256
    input_value = (nonce + counter) % 256
    
    # Apply SubBytes (the block cipher)
    keystream_byte = sub_bytes(input_value)
    
    return input_value, keystream_byte


def generate_keystream(nonce, num_bytes):
    """
    Generate CTR mode keystream.
    
    Args:
        nonce: Nonce value (0-255)
        num_bytes: Number of keystream bytes to generate
        
    Returns:
        List of keystream bytes
    """
    keystream = []
    for counter in range(num_bytes):
        _, ks_byte = ctr_keystream_byte(nonce, counter)
        keystream.append(ks_byte)
    return keystream


def find_period(nonce):
    """
    Find the period of the keystream.
    
    The keystream repeats when we've cycled through all possible
    input values to SubBytes.
    
    Args:
        nonce: Nonce value
        
    Returns:
        Period length
    """
    seen = set()
    counter = 0
    
    while True:
        input_value, _ = ctr_keystream_byte(nonce, counter)
        
        if input_value in seen:
            # We've seen this input before, so the keystream will repeat
            return counter
        
        seen.add(input_value)
        counter += 1
        
        # Safety check (should never exceed 256 for 8-bit values)
        if counter > 256:
            break
    
    return counter


def part_a():
    """
    Part a) Using nonce = 01100101, write down the first 4 bytes
    produced with counter values 0,1,2,3.
    """
    print("="*70)
    print("PART A: First 4 Keystream Bytes")
    print("="*70)
    
    nonce_bits = [0, 1, 1, 0, 0, 1, 0, 1]
    nonce = bits_to_int(nonce_bits)
    
    print(f"\nNonce: {''.join(map(str, nonce_bits))} = {nonce} (decimal) = 0x{nonce:02X} (hex)")
    print(f"Block cipher: AES SubBytes")
    print(f"\nGenerating keystream bytes:")
    print(f"\n{'Counter':<10} {'Input':<15} {'SubBytes(Input)':<20} {'Output (binary)':<20}")
    print("-"*70)
    
    keystream_bytes = []
    for counter in range(4):
        input_value, ks_byte = ctr_keystream_byte(nonce, counter)
        keystream_bytes.append(ks_byte)
        
        print(f"{counter:<10} {input_value:<6} (0x{input_value:02X})   "
              f"{ks_byte:<6} (0x{ks_byte:02X})      {format(ks_byte, '08b')}")
    
    print("\n" + "="*70)
    print(f"✓ First 4 keystream bytes:")
    for i, byte in enumerate(keystream_bytes):
        print(f"  K[{i}] = {format(byte, '08b')} = {byte} = 0x{byte:02X}")
    print("="*70)
    
    return keystream_bytes


def part_b():
    """
    Part b) What is the period of the key-stream?
    """
    print("\n" + "="*70)
    print("PART B: Period of the Keystream")
    print("="*70)
    
    nonce_bits = [0, 1, 1, 0, 0, 1, 0, 1]
    nonce = bits_to_int(nonce_bits)
    
    print(f"\nNonce: {''.join(map(str, nonce_bits))} = {nonce}")
    print(f"\nAnalyzing period...")
    print(f"\nCTR mode generates inputs: (nonce + counter) mod 256")
    print(f"With nonce = {nonce}:")
    print(f"  Counter 0:   ({nonce} + 0) mod 256 = {(nonce + 0) % 256}")
    print(f"  Counter 1:   ({nonce} + 1) mod 256 = {(nonce + 1) % 256}")
    print(f"  Counter 2:   ({nonce} + 2) mod 256 = {(nonce + 2) % 256}")
    print(f"  ...")
    print(f"  Counter 255: ({nonce} + 255) mod 256 = {(nonce + 255) % 256}")
    print(f"  Counter 256: ({nonce} + 256) mod 256 = {(nonce + 256) % 256} ← repeats!")
    
    period = find_period(nonce)
    
    print(f"\n" + "="*70)
    print(f"✓ Period = {period} bytes")
    print(f"\nExplanation:")
    print(f"  - The counter cycles through 0, 1, 2, ..., 255")
    print(f"  - Each produces a unique input to SubBytes")
    print(f"  - After 256 iterations, (nonce + 256) mod 256 = nonce")
    print(f"  - The keystream repeats with period 256")
    print("="*70)
    
    return period


def part_c():
    """
    Part c) Can the computation of the keystream be easily parallelized?
    """
    print("\n" + "="*70)
    print("PART C: Parallelization of CTR Mode")
    print("="*70)
    
    print(f"\n✓ YES - CTR mode is HIGHLY parallelizable!")
    print(f"\nReasons:")
    print(f"  1. Each keystream byte is INDEPENDENT")
    print(f"     - K[i] = SubBytes(nonce + i)")
    print(f"     - No dependency on previous outputs")
    print(f"\n  2. Can compute any K[i] directly")
    print(f"     - Don't need K[0], K[1], ..., K[i-1] to compute K[i]")
    print(f"     - Just need nonce and counter value i")
    print(f"\n  3. Comparison with CBC mode:")
    print(f"     - CBC: Sequential (C[i] depends on C[i-1])")
    print(f"     - CTR: Parallel (K[i] independent of K[i-1])")
    print(f"\n  4. Practical advantages:")
    print(f"     - Can use multiple CPU cores efficiently")
    print(f"     - Random access to any position in keystream")
    print(f"     - Ideal for high-speed encryption")
    
    print("\nExample parallel computation:")
    nonce = 101
    print(f"  Thread 1: Compute K[0], K[4], K[8], ...")
    print(f"  Thread 2: Compute K[1], K[5], K[9], ...")
    print(f"  Thread 3: Compute K[2], K[6], K[10], ...")
    print(f"  Thread 4: Compute K[3], K[7], K[11], ...")
    print(f"  All can run simultaneously!")
    
    print("="*70)


def part_d():
    """
    Part d) How could known plaintext-ciphertext pairs be used to
    infer information about the key?
    """
    print("\n" + "="*70)
    print("PART D: Known Plaintext Attack on CTR Mode")
    print("="*70)
    
    print(f"\nScenario:")
    print(f"  - Intercepted ciphertext encrypted with CTR mode")
    print(f"  - Unknown block cipher E_K(·)")
    print(f"  - Have some known plaintext-ciphertext pairs")
    
    print(f"\n✓ Attack Strategy:")
    print(f"\n  1. CTR mode encryption: C[i] = P[i] ⊕ K[i]")
    print(f"     where K[i] = E_K(nonce + i)")
    
    print(f"\n  2. From known P[i] and C[i], recover keystream:")
    print(f"     K[i] = P[i] ⊕ C[i]")
    
    print(f"\n  3. Now we know: K[i] = E_K(nonce + i)")
    print(f"     This gives us input-output pairs for the block cipher!")
    
    print(f"\n  4. Attack possibilities:")
    print(f"     a) If we know many K[i] values:")
    print(f"        - We have many (nonce+i, K[i]) pairs")
    print(f"        - Can build a lookup table of E_K(·)")
    print(f"        - Decrypt other messages using same key")
    
    print(f"\n     b) If we can guess the nonce:")
    print(f"        - Verify by checking if E_K(nonce+i) = K[i]")
    print(f"        - Once nonce is known, we know all inputs")
    
    print(f"\n     c) Reuse of (nonce, key) pair:")
    print(f"        - If same nonce used twice with same key")
    print(f"        - C1[i] ⊕ C2[i] = P1[i] ⊕ P2[i]")
    print(f"        - Two-time pad attack possible!")
    
    print(f"\n  5. Key recovery:")
    print(f"     - With enough plaintext-ciphertext pairs")
    print(f"     - May be able to reverse-engineer the key K")
    print(f"     - Depends on strength of block cipher E")
    
    print(f"\nExample attack:")
    print(f"  Known: P[0] = 10110011, C[0] = 01001100")
    print(f"  Derive: K[0] = 10110011 ⊕ 01001100 = 11111111")
    print(f"  Know:   K[0] = E_K(nonce + 0)")
    print(f"  Use:    K[0] to decrypt other bytes at position 0")
    
    print(f"\n✓ Countermeasures:")
    print(f"  - NEVER reuse same (nonce, key) combination")
    print(f"  - Use strong, cryptographically secure block cipher")
    print(f"  - Use authenticated encryption (e.g., GCM mode)")
    
    print("="*70)


def main():
    """Main function to solve all parts of Exercise 4."""
    
    print("="*70)
    print("EXERCISE 4: CTR MODE WITH AES SUBBYTES")
    print("="*70)
    
    # Part a
    keystream = part_a()
    
    # Part b
    period = part_b()
    
    # Part c
    part_c()
    
    # Part d
    part_d()
    
    # Final summary
    print("\n" + "="*70)
    print("SUMMARY")
    print("="*70)
    print(f"\na) First 4 keystream bytes (nonce = 01100101):")
    for i, byte in enumerate(keystream):
        print(f"   K[{i}] = {format(byte, '08b')} = {byte} = 0x{byte:02X}")
    
    print(f"\nb) Period of keystream: {period} bytes")
    
    print(f"\nc) Parallelizable? YES - Each byte is independent")
    
    print(f"\nd) Known plaintext attack: Recover keystream K[i] = P[i] ⊕ C[i]")
    print(f"   Then use to decrypt other messages or analyze block cipher")
    
    print("\n" + "="*70)


if __name__ == "__main__":
    main()






